# I-3. 왜 과거의  모나드 강의들은 다 실패했을까?

(작성중)

~~대놓고 어그로를 끄는 공격적인 주제라 반격당하지 않으려면 심혈을 기울여 써야 합니다. 오래 걸리더라도 기다려 주세요.~~

------

왜 이렇게 오래 걸렸을까? 

모나드는 거의 20년 동안 함수형 프로그래밍의 뜨거운 이슈 중 하나였다. 그동안 만들어진 모나드 강의 및 튜토리얼들은 셀 수도 없을 만큼 많다. 모나드가 쉽게 설명될 수 있는 것이었다면 왜 이전의 모나드 튜토리얼들은 다 실패했을까?

이러한 질문은 지적 호기심의 측면에서만 중요한 것이 아니다. 나쁜 설명은 많은 경우 대상에 대한 결함 있는 이해로부터 비롯된다. 그러한 실패가 오랫동안 집단적으로 발생하였다는 사실은 대상에 대해 일반적으로 받아들여진 견해 자체에 오류가 있었음을 의미할 수 있다. 여기에 우리가 이 문제에 지대한 관심을 기울여야 하는 이유가 있는 것이다.

게다가 작동하는 모나드 강의를 만드는 것은 작금의 모나드 튜토리얼 비극을 끝내기 위해 우리가 해야 하는 두 가지 일 중 하나일 뿐이다. 다른 한 가지는 자꾸 재생산되는 나쁜 설명들을 뿌리뽑는 것이다. 단순히 그것들이 나쁘다고 말하는 것만으로는 불충분하다. 나쁜 설명들은 바탕이 되는 오류들을 제거하지 않으면 언제든 다시 되살아나고 만다. 과거의 실패에 대한 철저한 원인 분석과 반성, 그리고 그 반성에 바탕을 둔 비판만이 그들을 없앨 수 있다. 

이 글에서 우리는 역사를 거슬러 올라가 모나드가 처음에 어떻게 프로그래머들에게 이해되었고 그것이 어떻게 변화해 왔는지 볼 것이다. 독자들은 모나드를 프로그래머들에게 처음 소개한 이들이 어떤 실수를 범했고, 왜 그 실수들이 수정되지 못하고 더욱 큰 오류를 야기했으며, 그 결과 지금의 모나드 튜토리얼 비극을 발생시켰는지 알게 될 것이다.

이 모든 이야기의 교훈과 앞으로 같은 실패가 다시 발생하지 않게 할 수 있는 진정한 해결책은 마지막에 다루어진다.



## 1. 발단 - 재앙의 씨앗

#### 1-1. 실패의 역사적 뿌리

모나드는 Engenio Moggi에 의해 1988년<a href="#F1">[1]</a>에 처음으로 컴퓨터 과학 분야에 소개됐다. 

그는 `A`타입의 값을 반환하는 순수하지 않은 함수의 상당수를 어떤 타입 컨스트럭터 `T`에 대해 `T<A>`타입의 값을 반환하는 순수 함수로 대신 나타낼 수 있다는 데 주목했다. 

`T`가 모나드일 경우 모나드의 성질에 의해 `A`에서 `T<B>`로 가는 함수와 `B`에서 `T<C>`로 가는 함수의 합성도 항상 자연스럽게 정의할 수 있었다. 비 순수 함수와 그들 간의 합성을 모두 순수 함수만 가지고 나타낼 수 있었던 것이다. 이것을 이용하면 람다 대수의 틀 내에서 순수하지 않은 프로그램을 연구할 수 있다는 것이 Moggi의 아이디어였다.

물론 이 설명은 Moggi의 발견을 프로그래머들이 이해하기 쉽게 내가 다시 재구성한 것이다. Moggi가 스스로 그의 발견을 표현한 방식은 아주 달랐다. 1990년대 초에 실제로 일어난 일을 이해하려면 우리는 그의 표현을 볼 필요가 있다.

앞서 말한 실패할 수 있거나, 부수 작용이 있거나, 기타 여러 이유로 순수하지 못한 함수들을 그는 계산(computation)이라고 불렀다. 계산들을 순수 함수로 나타낼 수 있게 해주는 `T`들은 계산개념(notion of computation)이라고 불렸다.

계산개념에 대한 Moggi의 설명은 아래와 같다:

> The basic idea behind the categorical semantics below is that, in order to interpret a programming language in a category C, we distinguish the object A of values (of type A) from the object TA of computations (of type A), and take as denotations of programs (of type A) the elements of TA. In particular, we identify the type A with the object of values (of type A) and obtain the object of computations (of type A) by applying an unary type-constructor T to A. We call T a notion of computation, since it abstracts away from the type of values computations may produce.<a href="#F2">[2]</a>
> (아래의 범주론적 의미 체계의 바탕이 되는 아이디어는 이렇다. 카테고리 C안에서 프로그래밍 언어를 해석하기 위해 우리는 (A 타입의) 값들의 대상 A와 (A 타입의) 계산들의 대상 TA를 구분했고, (A 타입의) 프로그램을 TA의 원소로 나타냈다. 특히 우리는 (A 타입의) 값의 대상을 타입 A로 정하고 단항 타입 컨스트럭터 T를 A에 적용하는 것으로 (A 타입의) 계산의 대상을 얻었다. 우리는 T를 계산개념이라고 부른다. 그것은 계산이 생성할 수 있는 값으로부터 추상화된 것이기 때문이다.)

이 설명은 카테고리 이론의 용어 때문에 어려워 보이지만 핵심은 간단하다. 그것은 다음과 같은 것을 말하고 있다: 우리는 `A`타입의 값을 반환하는 계산들을 `A`가 아니라 `T<A>`타입을 갖는 것으로 보았다. 그 타입은 어떤 타입 컨스트럭터 `T`를 `A`에 적용하는 것으로 얻어진다. 우리는 그 `T`를 계산개념이라고 부른다.

Moggi는 이어 `Optional`과 `List`, `Reader`, `State`, `Continuation`등 오늘날 널리 쓰이는 대부분의 모나드들의 원형을 계산개념의 사례로 제시한다. 그의 추론은 `T`가 계산개념일 경우 `A`에서 `T<B>`로 가는 함수와 `B`에서 `T<C>`로 가는 함수를 합성할 수 있어야 하며, 이를 위해서는 `T`가 모나드가 되어야 한다는 것으로 이어진다.

Moggi의 설명은 초기 모나드 전도사들의 모나드 설명에 큰 영향을 끼쳤다. 프로그래밍의 모나드는 `T<A>`가 계산의 타입이 되는 `T`들로 이해되고 설명되었다. 문제는 이 간단해 보이는 설명 속에 적절하게 다루어지지 않으면 치명적인 오류를 낳을 수 있는 위험이 숨어 있었다는 것이다.



#### 1-2. 이상한 환상

주의 깊은 독자들은 이미 무언가 이상함을 눈치챘을 것이다. 어떻게 `Optional<A>`나 `List<A>`같은 것들이 계산의 타입이 될 수 있는가?

이 타입들이 계산과 같은 것을 나타내는 데 유용하다는 것은 사실이다. `Optional<T>`를 반환하는 함수들은 실패할 수 있는 계산을 나타낼 수 있다. `List<A>`를 반환하는 함수들은 비결정적인 계산을 나타낼 수 있다. 그러나 이 경우 계산을 나타낼 수 있는 건 모나드 타입들 자체가 아니다. 그 타입들을 반환하는 함수들이다. 

그럼에도 불구하고 Moggi의 논문은 이 두 타입 컨스트럭터의 원형을 계산개념의 첫 번째와 두 번째 사례로 소개한다. 어떻게 그것이 가능했을까? 왜 그 정의가 Moggi에게는 아무 문제를 일으키지 않은 것일까?

모든 의문은 Moggi가 다루는 계산들이 값이 아니라 람다 대수로 씌여진 표현식임을 인식하는 순간 풀린다. 그것들의 타입이 `T<A>`라는 건 단지 그것들이 `T<A>`타입을 반환하는 표현식이라는 것을 의미할 뿐이다. 이런 표현식들은 `T<A>`를 반환하는 0인수 함수나 마찬가지므로 그것들이 계산을 나타낼 수 있다는 건 놀랄 일이 아니다. 가령 `Optional<A>`를 반환하는 표현식이 실패할 수 있는 계산을 나타낼 수 있음은 당연하다.

그러나 이런 맥락은 명백히 아무런 설명 없이 이해할 수 있는 것이 아니다. 문제는 모나드를 `T<A>`가 계산의 타입이 되는 `T`라고 설명한 초창기의 모나드 전도사들 중 누구도 이것을 말해 주지 않았다는 것이다. 오히려 그들은 `T<A>`타입이 계산을 나타낸다고 주장함으로써 혼란을 더욱 더 악화시켰다. Philip Wadler의 이 설명을 보라.

> Just as the type Value represents a value, the type M Value can be thought of as representing a computation.<a href="#F4">[4]</a>
> (Value타입이 값을 나타내듯이, M Value타입은 계산을 나타내는 것으로 생각될 수 있다.)

뭐라고 해야 할까? 내가 보기엔 이 설명은 그냥 틀렸다. 명백히 대부분의 모나드 `M`에 대해 `M Value`타입은 계산을 나타내지 않는다. 그러한 타입을 반환하는 표현식이 계산을 나타낼 수 있는 것은 사실이다. 하지만 그렇다고 그 타입이 계산을 나타낸다고 할 수는 없다. 프로그래머에게 타입의 의미는 언제나 그 타입의 값에 관한 것이다. 

Wadler가 무엇을 생각하고 위와 같은 설명을 한 것인지는 불분명하다. 그럼에도 이런 설명들은 그것이 정확히 무엇을 의미하는지에 대한 최소한의 합의조차 없이 함수형 프로그래밍 커뮤니티 전체로 퍼져 나갔다.

많은 사람들은 그 설명들을 이런 의미로 받아들였다: `T<A>`는 어떤 계산과 밀접하게 관계된, 그것의 본질적인 무언가를 나타낸다.

그러나 그 무언가는 대체 무엇인가? 대부분의 `T<A>`의 의미가 어떤 식으로든 계산과 관계가 있는 것은 사실이다. `T<A>`를 반환하는 함수나 표현식이 계산이 되려면 당연히 `T<A>`도 계산과 관계가 있기는 해야 한다. 그러나 그 관계가 무엇인지는 모나드마다 다르다. 일관된 의미에서 `T<A>`가 계산의 무엇을 나타낸다고 하는 것은 불가능하다.

다른 많은 사람들은 그 설명들을 이런 의미로 받아들였다: `T<A>`는 계산의 의미를 확장한 무언가를 나타낸다. `Optional<A>`나 `Set<A>`타입의 값들은 계산이 아닌 것처럼 보인다. 그러나 그들도 어떤 관점에서는 계산으로 볼 수 있을 것이다.

그러나 정확히 어떤 의미에서 그렇다는 말인가? 계산의 의미를 정확히 어떻게 확장하는 것이 그것을 가능하게 하는가? 

누구도 만족스럽게 대답할 수 없는 이런 질문들은 물론 애초에 잘못된 전제를 받아들인 것의 결과다. `T<A>`는 계산이나 계산의 무언가를 나타내지 않는다. 그것은 오직 그것을 반환하는 함수나 표현식이 계산을 나타내내도록 하는 속성을 가질 뿐이다. 계산개념은 단지 우발적으로 `T<A>`를 반환하는 함수나 표현식이 계산을 나타내는 `T`들에 지나지 않는다.

그러나 1990년대 초 당시에는 아무도 이것을 말해 주지 않았다. `T<A>`가 자체로 계산을 나타낸다는 부정확하고 혼란스러운 설명만 끝없이 되풀이되며 퍼져 나갔다. 그 결과 이상한 환상이 만들어졌다. 각 모나드가 실제로 계산의 개념으로써 어떤 계산의 본질적인 무언가를 나타낸다는 것이다. 그 위에 있는 프로그래밍의 모나드, 즉 계산개념은 그 모든 계산의 개념을 묶어 주는 아주 추상적인 무언가라고 믿어졌다.



#### 1-3. 계산에 대한 견해들

Moggi에게 계산은 처음부터 명확하게 정의된 개념이 아니었다. 그는 그의 논문 어디에서도 그것의 정의를 제공하지 않는다. 우리는 단지 그 단어의 활용을 보고 그것이 어떤 의미로 쓰이고 있는지 짐작할 수 있을 뿐이다. 가령, 다음 문장을 보라.

> This approach was later extended, following a similar methodology, to consider other features of computations like nondeterminism (see [Sha84]), side-effects and continuations (see [FFKD86, FF89]).
> (이 접근은 나중에 같은 방법으로 비결정성([Sha84]을 보라), 부작용과 Continuation([FFKD86, FF89]을 보라) 등의 다른 *계산의 요소*에도 적용된다.)<a href="#F2">[2]</a>

여기서 계산은 수학적인 순수 함수와 구분되는, 순수하지 않은 함수나 식들을 통칭한다. 계산이라는 단어의 이와 같은 사용은 Moggi의 논문 전체에서 일반적이다.

나중에 Moggi는 계산의 범주론적 의미론(A categorical semantics of computations)이라는 이름으로 모든 계산에 대해 유효한 이론적인 모델을 제시한다. 계산은 이 모델에서 어떤 계산개념 `T`에 대해 `T<A>`타입의 람다 표현식으로 나타내진다.

일부는 이 모델이 계산에 형식적인 정의를 제공한다고 보았다. Moggi의 논문에서 계산은 처음에는 순수하지 않은 함수나 식들을 느슨하게 일컫는 의미로 사용된다. 그러나 그것은 이후 상술한 모델을 통해 형식적으로 재정의된다. 따라서 그 모델로 다룰 수 있는 모든 `T`가, 즉 모든 모나드가 계산개념이며 그러한 `T`를 통해 `T<A>`타입으로 나타낼 수 있는 모든 것이 계산이라고 보아야 한다는 것이다.

이 주장은 설득력이 있다. Moggi에게 실제로 계산을 새로 정의하려는 의도가 있었든 그렇지 않았든 그의 모델을 통해 계산을 더 넓게 정의하는 것은 충분히 그럴듯하다. 

그러나 앞에서 문제가 된 `Optional<A>`와 `List<A>`는 단순히 그런 더 넓은 의미의 계산에만 속하는 것이 아니다. 그들은 Moggi가 그의 논문에서 순수하지 않은 식이라는 훨씬 더 좁은 의미에서 계산의 타입이라고 부른 것들 중 하나였다.

Moggi는 왜 이들을 계산의 타입이라고 부른 것일까? 간단하다. `A`타입을 반환하는 실패할 수 있는 프로그램은 `Optional<A>`타입의 람다 표현식으로 나타낼 수 있다. `A`타입을 반환하는 비결정적인 프로그램은 `List<A>` 타입의 람다 표현식으로 나타낼 수 있다. 요컨대 그들은 `T<A>`를 반환하는 표현식이 계산을 나타낼 수 있는 `T`다. 그것이 이유의 전부다.

진실은 Moggi 본인에게는 `Optional<A>`나 `List<A>`타입의 값 자체를 계산이라고 부르기 위해 후대의 모나드 전도사들이 시도한 것과 같은 기묘한 논리적 곡예가 필요하지도 않았으며 실제로 그런 곡예를 하지도 않았다는 것이다. 

모나드가 `T<A>`가 계산의 타입을 나타내는 `T`라고 주장한 많은 모나드 전도사들은 이 자명한 사실을 완전히 놓쳤다. 대신 그들은 `Optional<A>`나 `List<A>` 같은 타입의 값들도 어떻게든 계산으로 볼 수 있게 해 주는 각종 난해하고 혼란스러운 사고를 개발해냈다. 그 사고는 대개 간단한 말로는 표현될 수 없었으므로 그들의 모나드를 설명하는 능력의 상실은 필연적이었다.

모나드와 계산을 진정으로 설득력 있게 연결하는 설명은 나중에 만들어졌다. `T<A>`가 아니라 `T<A>`를 반환하는 함수들을 계산이라고 하는 것들이 바로 그것이었다. 

모나드 타입 자체를 계산과 연결짓는 정통적인 입장을 고수한 이들에게 이 설명은 종종 부정확하고 피상적인 것으로 취급되었다. 그러나 실제로 Moggi의 사고를 더 정확하게, 발전적으로 계승한 것은 오히려 이 설명이다.

무엇보다 그것은 `T<A>`타입의 표현식으로 나타내질 수 있는 인자 없는 프로그램들 뿐 아니라 인자를 가진 프로그램들까지 계산이라고 부를 수 있게 한다. 그것은 논리적으로 더 바람직할 뿐 아니라, Moggi의 모델 자체도 더 자연스러운 언어로 표현될 수 있게 해 준다. 우리는 `T`가 모나드가 되어야 하는 이유를 쉽게 이해할 수 있다. `A`에서 `B`로 가는 계산과 `B`에서 `C`로 가는 계산은 합성 가능해야 하며, 이는 즉 `T`가 `A`에서 `T<B>`로 가는 함수와 `B`에서 `T<C>`로 가는 함수를 합성할 수 있게 해 주는 타입 컨스트럭터, 즉 모나드가 되어야 함을 의미하기 때문이다.

아무튼 더 나은 대안은 적어도 1990년대 초까지는 발견되지 않았다. 당시에는 `T<A>` 자체를 계산과 연결짓는 것이 모나드를 직관적으로 설명하는 알려진 유일한 방법이었다. 문제는 아무도 그 정확한 연결 고리를 알지 못했다는 거였다.



#### 1-4. 모나드와 계산개념

Moggi가 발견한 것은 결국 모나드의 가능한 한 가지 활용일 뿐이다. 모나드가 프로그래밍에서 오직 그 목적으로만 영원히 활용되리라는 보장은 없다. 모나드가 본래 얼마나 보편적이고 자주 발견되는 구조인지를 감안한다면 더욱 그렇다.

모나드를 처음 프로그래밍 언어에 도입한 이들이 충분히 사려 깊고 조심스러웠다면 어떻게 했을까?  그들은 모나드와 계산개념이라는 두 개념의 분리를 유지시켰을 것이다. 그들은 모나드를 이런 식으로 설명했을 것이다.

 - 모나드는 타입 컨스트럭터 `T`중 임의의 `A`, `B`에 대해 `A->B` 타입의 함수를 `T<A>->T<B>`타입으로 변환할 수 있으며, `A`에서 `T<A>`로의 형 변환과 `T<T<A>>`에서 `T<A>`로의 형 변환을 모두 갖는 것을 뜻한다.

 - 그것이 유용한 이유는 `T`가 모나드일 경우 모나드의 성질에 의해 `A`에서 `T<B>`로 가는 함수와 `B`에서 `T<C>`로 가는 함수의 합성을 자연스럽게 정의할 수 있기 때문이다. `A`에서 `T<B>`로 가는 함수는 `A`에서 `B`로 가는 함수의 어떤 논리적 확장을 나타낼 수 있다. 이와 같은 모나드의 특성은 특정한 비 순수성을 가진 프로그램의 요소, 즉 계산을 타입으로 모델링하는 데 쓰일 수 있으며 이는 매우 유용하다.

물론 이 설명은 내가 [모나드에 대한 작동하는 설명](I-2.md)에서 시도한 설명과 정확히 같다. 이 정의와 설명이 채택되었다면 모나드 튜토리얼들의 실패가 지금처럼 20년이 넘게 이어지지는 않았으리라. `T<A>`를 반환하는 함수가 계산이 되는 `T`들을 따로 뭐라고 부르든 거기서 무슨 오류가 발생하든 마찬가지다. 피해는 발생했겠지만 그 피해가 지금처럼 길게 이어지지는 않았을 것이다.

곧 보게 되겠지만 모나드를 처음 프로그래밍 언어에 도입한 이들은 정확히 이것에 반대되는 선택을 했다. 그들은 모나드에서 그들이 불필요하다고 판단한 의미와 용도를 빼고 그들이 중요하다고 판단한, 그러나 당시 그들을 포함한 그 누구도 정확히 설명할 방법을 몰랐던 그 계산개념으로써의 의미와 용도만 남기려 했다. 선구자들이 계산개념 속에 이상한 환상의 형태로 남겨 놓은 작은 재앙의 씨앗을 완전한 재앙으로 만든 것은 바로 그 선택이었다.



## 2. 전개 - 끔찍한 선택

#### 2-1. 모나드의 '개선'?

모나드를 실제로 프로그래밍 언어에서 사용할 수 있는 유용한 툴로 처음 소개한 건 Philip Wadler로 여겨진다. 

1990년의 논문에서 Wadler는 모나드를 비교적 원본에 가까운 형태로 소개한다. 모나드는 `A->B` 타입의 함수를 `T<A>->T<B>`타입으로 바꾸는 `lift`, `A`타입을 `T<A>`타입으로 바꾸는 `unit`, 그리고 `T<T<A>>`타입을 `T<A>`타입으로 바꾸는 `join`함수를 가진, 그리고 이들이 특정 조건을 만족시키는 타입 컨스트럭터였다.<a href="#F3">[3]</a>

그러나 그로부터 2년 후 같은 저자는 모나드를 전혀 다르게 소개한다. 모나드는 `A->T<A>`타입의 함수 `unit`과 `T<A>->(A->T<B>)->T<B>` 타입의 함수 `bind`를 가진, 그리고 이들이 특정 조건을 만족시키는 타입 컨스트럭터다.

>For our purposes, a monad is a triple (M, unitM, bindM) consisting of a type constructor M and a pair of polymorphic functions.<a href="#F4">[4]</a>
>(우리의 목적상, 모나드는 타입 컨스트럭터 M과 두 다형 함수들로 이루어진 삼중쌍 (M, unitM, bindM)이다.)

물론 이 정의는 아무런 근거도 없이 갑자기 튀어나온 것은 아니다. 그것은 모나드와 수학적으로 동치인 Kleisli triple이라는 것의 정의를 약간 변형한 것이다.

1991년에 Moggi의 모나드에 대한 두 번째 논문<a href="#F2">[2]</a>이 출판된 이래 계산개념은 주로 이 Kleisli triple을 통해 설명되었다. 그것의 정의가 모나드의 원본 정의보다 계산개념의 계산을 나타내는 용도와 훨씬 더 깊은 관련을 가지고 있기 때문이었다. 

Wadler의 새로운 모나드 정의도 마찬가지였다. `lift`와 `join`은 계산과 관련된 특별한 용도가 없는 반면, `bind`는 `A`를 반환하는 계산 (상술했듯이 이들은 `T<A>`를 반환하는 함수로 구현된다) 과 다른 계산을 합성할 때 직접적으로 이용될 수 있었다. Wadler의 논문은 주로 모나드로 계산을 나타내는 방법에 관한 것이었으므로 계산과 직접적인 관련이 있는 정의를 사용하는 것이 더 편한 건 당연했다.

물론 이 모든 것은 1992년의 그 논문의 맥락에서 그렇다는 것이다. 프로그래밍의 모나드를 정의하는 방법으로써 무엇이 더 나은가는 완전히 다른 문제다. 

그럼에도 많은 사람들은 Wadler가 편의를 위해 변형한 모나드의 정의를 마치 프로그래밍의 모나드에 대한 더 나은 정의인 것처럼 받아들였다. 아무튼 모나드는 실제로 프로그래밍에서 주로 계산을 나타낼 때 사용되었고, `bind`는 실제로 `join`과 `lift`보다 유용했다. 

결국 4년 후 하스켈은 `bind`가 `>>=`로 바뀐 것을 빼면 정확히 Wadler의 두 번째 모나드 논문에서 제안된 것과 같은 형태로 모나드 타입클래스를 도입한다. 나중에 모나드를 도입한 다른 많은 프로그래밍 언어들도 하스켈의 선택을 따랐다.

그러나 그것은 그들이 기대했던 것처럼 프로그래밍의 모나드를 더 직관적이고 이해하기 쉽게 만들어 주지는 않았다. 모나드는 훨씬 더 당황스럽고 이해하기 힘든 개념이 되었다. 이후 20년이 넘게 이어진 모나드 튜토리얼의 일관된 실패는 바로 1996년의 그 선택의 결과였다.



#### 2-2. 실패의 이유들

무엇이 문제였을까? 그들은 단지 모나드에서 잘 사용되지 않는 기본 함수 두 개를 빼고 더 자주 사용되는 함수를 대신 넣었을 뿐이다. 당연히 이것은 모나드를 더 직관적이고 이해하기 쉽게 만들어주지 않을까?

아니다. 그 생각이 얼마나 얕고 어리석은 것인지 보이는 데는 특별히 고차원적인 논리도 필요치 않다. 가장 피상적인 관찰조차 그것의 오류를 극명하게 보여준다.

우선 `>>=`는 알려진 모든 모나드에서 `lift`와 `join`보다 훨씬 더 복잡하다. 이론적으로는 `>>=`가 더 간단한 함수고 `lift`와 `join`이 `>>=`로부터 정의되는 더 복잡한 함수인 경우도 생각할 수 있는 것은 사실이다. 그러나 그런 게 정말로 있을 수 있는지는 의심스럽다.

`lift`와 `join`이 기본 함수라면 프로그래머들이 개별 모나드의 `>>=`를 직접 공부할 필요는 없다. `>>=`는 항상 두 함수로부터 같은 형태로 정의 가능하기 때문이다. `>>=`는 그냥 `lift`와 `join`에 기반한 고차 함수 중 하나가 되었을 것이다. 개별 모나드들은 훨씬 더 간단한 `lift`와 `join`을 공부하는 것만으로도 충분히 배울 수 있었을 것이다.

이 차이는 크다. 나는 이미 [모나드에 대한 작동하는 설명](I-2.md)에서 `Optional` 모나드와 `List` 모나드를 코드 한 줄도 없이 쉽게 설명한 바 있다. 그것은 내가 이 모나드들을 `lift`와 `join`을 통해 설명했기 때문에 가능했다. `>>=`도 그런 식으로 설명할 수 있을까? `Optional`의 것은 아마 가능할 것이다. `List`의 것은 어떨까? 억지로 하면 불가능하지는 않겠지만 그 설명을 독자들이 쉽게 이해할 수 있을지는 별개의 문제다.

`State`나 `Cont`등의 비교적 난해한 모나드에서 차이는 더욱 커진다. 이들의 `>>=`연산자를 코드만 보고 바로 이해하는 건 하스켈 초보자들에게는 결코 쉬운 일이 아니다. `lift`와 `join`는 논리적으로나 실제 구현으로나 압도적으로 더 간단하다. 

그러나 `IO` 모나드만큼 두 정의의 차이를 극명하게 보여주는 모나드는 없을 것이다. 나는 [모나드에 대한 작동하는 설명](I-2.md)에서 그것을 코드 한 줄 없이 설명해낸 바 있다. 그 설명에는 단 하나의 단점만 있을 뿐이다. 너무나 짧고 쉬워서 독자들로 하여금 `IO` 모나드가 본래 얼마나 어려운 주제였는지를 망각하게 한다는 것이다.

독자들은 지난 20년 동안 전체 하스켈 커뮤니티가 그 `IO` 모나드 하나를 설명하지 못해서 가능한 모든 수단을 동원했다는 사실을 아는가? 그리고 우리는 그것 모두가 완전하게, 가능한 한 가장 비참하게 실패하는 꼴을 보아 왔다. 그들의 기이할 정도로 일관된 실패는 물론 정의의 차이만으로는 다 설명되지 않는다. 그러나 비효율적인 정의에 대한 집착이 그들이 실패해 온 이유에서 큰 비중을 차지하고 있다는 것은 확실하다.

가장 피상적인 관점에서 보더라도 하스켈이 모나드에서 `join`과 `lift`의 기본 함수 지위를 박탈하면서 한 일은 `>>=`를 항상 간단한 두 함수로 쪼갤 수 있다는, 모나드에 본원적으로 존재했던 구조 하나를 거세시킨 역-리팩토링에 지나지 않는다. 대부분의 독자들은 굳이 다른 문제점까지 들어 보지 않아도 이것 하나만으로 그 선택이 얼마나 잘못된 것이었는지 능히 짐작할 수 있을 것이다.

`join`과 `lift`를 버린 하스켈의 모나드 구현은 그 외에도 많은 문제를 야기했다. 그것은 카테고리 이론에서 유래한 또 하나의 유용한 개념 도구, `Functor`와 모나드의 연결도 약화시켰다. 결과적으로 모나드를 배우고자 하는 이들은 모나드를 `Functor`라는 중간 과정 없이 처음부터 이해해야 했으며, 이는 그들이 모나드를 배우는 것을 더 어렵게 했을 뿐 아니라 연관된 두 개념을 마치 별개의 개념처럼 배우게 함으로써 하스켈 자체의 학습 효율도 떨어뜨렸다.

하스켈의 모나드 구현은 프로그래머가 무엇이 모나드고 무엇이 모나드가 아닌지 스스로 구분하는 것도 힘들게 했다. `lift`와 `unit`, `join`으로 이루어진 정의는 개념화하기 쉽다. 왜 `Optional`이 모나드일까? 임의의 함수에 대해 그걸 바탕으로 하는 `Optional`사이의 함수가 항상 존재하며, 값은 값을 가진 `Optional`로 볼 수 있고, `Optional`의 `Optional` 또한 `Optional`로 볼 수 있기 때문이다. 어떤 타입 컨스트럭터에 `>>=`를 정의할 수 있는지 판단하는 건 훨씬 어렵다. 그것은 일반 사용자들이 스스로 모나드를 찾는 것을 사실상 불가능하게 했고 그들의 모나드에 대한 이해는 물론 생산성까지 추락시켰다.



#### 2-3. 불구가 된 모나드

그러나 진정으로 치명적인 문제는 따로 있었다. 하스켈의 모나드 구현은 모나드 전체를 Moggi가 발견한 그것의 특정 용도, 즉 계산을 나타내는 용도에 종속시켰다.

결과적으로 모나드는 훨씬 덜 매력적인 개념이 되었을 뿐 아니라, 더 취약해졌다. 이제 그것은 오직 그것을 정당화하는 단 하나의 용도가 완전히 이해되었을 때만, 그리고 그 용도가 모나드를 완전히 이해시키기에 충분할 경우에만 완전히 이해될 수 있었다. 둘 모두 사실이 아니었고, 이는 결국 모나드를 이해할 수 없는 개념으로 전락시켰다.

모나드라는 개념이 Moggi가 그것을 발견하기 훨씬 전부터 수학에서 쓰인 데는 이유가 있다. 그 개념은 스스로를 정당화하기에 충분할 만큼의 자연스러움을 가지고 있었다. 모나드의 본래 정의를 채택하는 한 프로그래밍의 모나드도 마찬가지다. `lift`와 `unit`, `join`은 이해하기 쉽고 의미도 명백하다. 이들에 의존하는 정의를 이해하기 위해 굳이 계산개념 따위는 필요치 않다.

모나드의 새로운 정의는 이 모든 것을 바꿨다. 그것의 비직관적이고 비대칭적인 생김새는 그것을 처음 접하는 이들에게는 거의 임의적인 것처럼 보였다. 모나드는 더 이상 자연스러운 개념이 아니었고 정당화를 절실히 필요로 했다. 그리고 그것의 기이한 새로운 정의를 정당화할 방법은 그것의 알려진 유일한 용도, 계산개념으로써의 용도에 호소하는 것 말고는 없었다.

물론 이러한 상황은 어느 정도 하스켈 개발진들이 의도한 것이기도 했다. 그들에게는 모나드에서 Moggi가 발견한 용도와 무관한 것들은 모두 불필요해 보였다. 기존 정의는 모나드가 계산개념이 아니라 다른 것일 수도 있다는 인상을 준다는 바로 그 이유 때문에 폐기되어야만 했다. 새로운 정의는 그것이 오직 계산개념으로만 이해될 수 있다는 바로 그 이유로 인해 선택됐다.

그러나 그런 선택은 정말로 바람직한 것인가? 모나드의 모든 부분에서 오직 계산과 관계된 것만 남겨서 오직 계산개념만으로 모나드 전부를 설명할 수밖에 없도록 하는 것이 정말 모나드의 설명에 도움을 주기는 하는 것인가?

내 [모나드에 대한 작동하는 설명](I-2.md)을 보라. 그것은 우선 모나드를 본래 정의를 통해 소개한 후 그것의 계산을 나타내는 용도는 나중에 '모나드가 프로그래밍에서 유용한 이유는 무엇인가?' 라는 질문에 대한 대답으로써 따로 다룬다. 

계산과 무관한 정의를 이용한 것이 모나드의 계산을 나타내는 용도를 설명하는 걸 방해했는가? 두 설명이 충돌하거나 혼란을 불러일으켰는가? 아니다. 둘은 오히려 서로를 보완했다. 모나드의 간단한 정의가 그것에 직관성을 부여하고 계산개념으로써의 용도가 그것에 필요성을 부여했기에 그것은 훨씬 더 견고한 개념이 될 수 있었다. 무엇이 문제인가?

애초에 모나드를 오직 계산개념만 가지고 설명하는 것은 가능하기는 한 것인가? 나는 회의적이다. 이미 지적했듯이 올바르게 이해된 계산개념은 `T`나 `T<A>`의 의미에 대한 설명이 아니다. `T<A>`를 반환하는 함수의 의미에 대한 설명이다. 

당신이 모나드를 처음 접하는 사람이라고 생각해보라. 당신은 순수 함수만으로 순수하지 않은 실제 프로그램을 다룰 수 있게 하기 위해 특별한 도구를 도입했다는 이야기를 듣는다. `T<A>`도 아니고 그걸 반환하는 표현식이 순수하지 않은 프로그램을 나타내도록 하는 `T`들의 분류가 바로 그것이다. 당신은 정말로 이런 설명을 납득할 수 있는가? 

모나드와 계산 사이의 연결이 부자연스럽고 간접적인 이유는 애초에 그것이 계산을 나타내기 위해 만들어진 것이 아니기 때문이다. 계산을 나타내는 데 사용될 수 있다는 것은 모나드의 차후에 발견된 다른 용도다. 그 용도는 모나드와 같은 개념이 왜 정확히 지금과 같은 형태로 존재하는지 설명해 주지 못한다. 그걸 설명할 수 없다면 모나드를 처음 접하는 이들에게 모나드를 직관적으로 설명할 방법도 없다.

1996년의 하스켈 개발자들의 선택을 옹호할 수 있는 논거는 하나뿐이다. 프로그래머가 굳이 모나드의 본래 정의를 알 필요는 없으며, 그러한 것을 공부하는 것이 일종의 지적 역량의 낭비에 해당한다는 것이다.

그러나 인간의 기억은 컴퓨터 메모리 같은 것과는 다르다. 우리가 어떤 개념을 얼마나 더 쉽게 기억할지는 기억할 내용이 많냐 적냐보다는 그것이 우리가 아는 다른 개념들과 얼마나 더 밀접하게 얽혀 있느냐에 달려 있다. 모나드의 단순하고 직관적인 정의와 그 정의로부터 모나드의 계산개념으로써의 기능을 유도할 수 있다는 사실은 우리가 계산개념을 이해하는 것을 방해하기는커녕 돕는다. 훨씬 더 쉬운 것으로부터의 연결고리가 그것을 지탱하기 때문이다.

모나드의 정의의 변경은 모나드 튜토리얼들에 실질적으로 아무 이익을 가져다주지 못했을 뿐 아니라 그 개념을 훨씬 덜 흥미롭게 함으로써 직접적인 해악을 끼쳤다.

많은 사람들이 모나드라는 개념에서 매력을 느낀 건 단지 그것이 계산을 나타낼 수 있다는 사실 때문만은 아니었다. 그러한 쓰임새가 계산이나 함수의 확장 따위와는 전혀 무관해 보이는 간단한 정의로부터 발생한다는 사실 때문이기도 했다. 새로운 모나드 개념에 그런 매력은 없었다. 그것은 이전보다 훨씬 덜 매력적인 것이 되었고 정확히 같은 정도로 덜 직관적인 것이 되었다.



#### 2-4. 은유로의 추락

앞 절에서 지적한 것들은 당시 계산개념으로써의 모나드가 올바르게 이해되었더라도 여전히 문제가 되었을 것이다. 실제로는 그것조차 사실이 아니었다. 당연히 실제 상황은 거의 비교조차 불가능할 만큼 훨씬 더 나빴다.

계산개념은 Wadler에 의해 프로그래머들에게 처음 소개되었을 때부터 이미 횡설수설이었다. `Optional`과 `List`를 계산의 타입이라고 부르는 그 말도 안 되는 소리들은 명백히 적절한 맥락 없이는 이해될 수 없었다. 아무도 그 맥락이 뭔지 정확히 알지 못했으므로 모나드 자체가 이해될 수 없는 것으로 전락하는 것은 시간문제였다.

후에 모나드 전도사들이 어떻게든 그 맥락을 만든답시고 한 시도들은 너무 나빠서 직접 보기 전에는 그 해악을 상상하기조차 어렵다. 아래는 가장 잘 알려진 모나드 튜토리얼 중 하나인 Jeff Newbern 외 기타 저자들의 All about monads<a href="#F5">[5]</a>에서 내가 발췌한 것이다.

> ... Perhaps one of the most helpful glosses of "monad" in Haskell's sense comes from Simon Peyton-Jones. He pointed out that in F#, they are called "workflows", a term he deemed very sensible...
> (... 어쩌면 하스켈의 "모나드" 에 대한 가장 도움이 되는 직관화 중 하나는 Simon Peyton-Jones의 것일지도 모른다. 그는 F# 에서는 모나드가 그가 아주 적합하다고 생각하는 단어인 "워크플로우" 로 불린다는 것을 지적했다...)
> 
> As much as anything, monads are strategies for solving coding problems that recur often, regardless of what you're writing. In this sense, the concept of the monad resembles what's been called "cross-cutting concerns" in software engineering. The List solves a common problem: you need a very basic collection of items of the same type, with some easy-to-understand behavior and performance characteristics. And then there's the Maybe type, which rescues you from having to write lots of null pointer checks -- or else debug code that doesn't have enough of them. And I/O makes it possible to interact with a program at all.
> (무엇보다, 모나드는 당신이 어떤 작업을 하든 간에 자주 나타나는 코딩 문제를 풀기 위한 전략이다. 이런 의미에서 모나드의 개념은 소프트웨어 공학에서 "횡단 관심사" 라고 불리는 것과 유사하다. List는 한 가지 일반적인 문제를 해결해 준다: 당신은 같은 타입을 가진 값들의 이해하기 쉬운 행동 및 성능상의 특징들을 가진 기본 묶음이 필요하다. Maybe는 아무리 많아도 부족한 널 포인터 체크 관련 디버그 코드를 일일히 작성할 필요로부터 당신을 구제해 준다. 그리고 I/O는 프로그램과 상호작용하는 것 자체를 가능하게 한다.)
> 
> More than this, however, monads help make strategies composable. The monad is a kind of meta-strategy for combining computations into more complex computations. Think of monads as a kind of type-disciplined approach to "pipelines" inside your program...
> (게다가 모나드는 전략들을 합성 가능하게 하는 것을 돕는다. 모나드는 계산을 더 복잡한 계산으로 합치는 일종의 메타-전략이다. 모나드를 당신의 프로그램 안의 "파이프라인" 에 접근하는 타입 제약적인 접근이라고 생각하라...)
> 
> In short, a monad is a way to structure computations in terms of values and sequences of computations using typed values. But since sequencing is often done by feeding one function into the next, you get some type discipline and computational leverage over what kinds of operations can follow previous operations. For those coming from languages where the semicolon is a statement separator in imperative control flow, the metaphor of "programmable semicolon" has helped many understand the advantages of monads. The monad determines how combined computations form a new computation and frees the programmer from having to code the combination manually each time it is required. Think of monads as "statically typed filters" (in the Unix sense of "pipes and filters") and you may be halfway there.
> (요컨대, 모나드는 타입이 있는 값을 이용해서 계산을 값과 계산들의 연쇄로 구조화하는 방법이다. 그러나 연쇄가 주로 한 함수를 다음 것에 전달하는 방식으로 이루어지므로, 앞의 연산 뒤에 어떤 연산이 이어질 수 있는지에 대한 몇몇 타입 규약과 계산상의 레버리지가 주어진다. 세미콜론이 제어 명령들 사이의 문장 구분자로 사용되는 언어를 공부하다 온 이들에게는 "프로그래밍 가능한 세미콜론" 의 비유가 모나드의 여러 유용성을 이해하는 데 도움을 주었다. 모나드는 결합된 계산이 어떻게 새로운 계산을 만들어 내는지를 결정하며 프로그래머들이 매번 필요할 때마다 결합을 위한 코드를 직접 작성하지 않을 수 있도록 해 준다. 모나드를 "정적 타입이 지정된 필터" (Unix의 "파이프와 필터"와 같은 의미에서) 라고 생각하라. 그러면 당신은 절반 정도 온 것이다.)

그래서 이게 다 무엇인가? 글쎄, 그냥 보이는 그대로 받아들이면 된다: 울부짖으며 승천하는 개소리. 이런 것도 글이라고 열심히 썼을 저자에게는 미안한 말이지만 나는 단지 조롱을 위해 이것을 길게 인용한 것이다.

위 글에서 명료한 것은 아무도 그것을 이해할 수 없다는 사실 뿐이다. 도대체 저자가 말하는 "전략" 이 뭔가? 그는 그것이 자주 발생하는 코딩 문제를 해결한다는 것과 "횡단 관심사" 와 유사하다는 것 말고는 그것에 대한 아무 설명도 하지 않는다. 그는 대신 `List`와 `Maybe`와 I/O를 사례랍시고 보여 주지만 각각이 "전략" 이라고 주장되는 근거들은 너무나 달라서 그들 사이에서 의미 있는 공통점을 찾는 건 순수하게 논리적으로 불가능하다. 하물며 그런 "전략" 을 합성한다는 건 또 무슨 소리인가? 전혀 어디서도 정확한 정의가 설명된 적이 없는 "계산" 은 왜 또 갑자기 튀어나와서 가장 중요한 것이 되는가?

이 글에서 언급하고 있는 많은 것들이 실제로 모나드와 관계가 있는 것은 사실이다. 그러나 단순히 모나드와 관계가 있는 걸 다 끌어다 붙인다고 해서 그게 모나드에 대한 설명이 되지는 않는다. 어떤 개념이 이해가 되려면 우선 그 개념이 어떤 범주에 속하는 것인지부터 이해가 되어야 한다. 모나드가 "워크플로우" 였다가 "전략" 이었다가 "메타-전략" 이었다가 "계산의 구조화 방법" 이 되는 위 설명을 모나드를 처음 접하는 이들이 이해할 방법은 없다.<a href="#F6">[6]</a>

저자에게는 왜 이런 혼란스럽고 명백히 누구에게도 아무 도움도 되지 않는 횡설수설이 필요했을까? 다음과 같은 말을 하기 위해서다.

> Let's look at Maybe... which represents the type of computations which may fail to return a result. 
> (Maybe를 보자... 이것은 결과를 반환하는 데 실패할 수 있는 계산의 타입을 나타낸다.)

훗날 모나드가 계산을 나타낸다는 말은 모나드에 대한 은유 중 하나로 받아들여졌다. 아무도 정확한 정의를 말하지 않는 계산이라는 말 자체의 모호한 의미, 어떻게 해석해야 할지 불분명한 위와 같은 혼란스러운 말들이 그것을 은유 외의 다른 어떤 것으로도 생각할 수 없게 했다.

잘 알려져 있지 않은 사실은 그 은유의 뿌리가 된 계산개념이라는 용어가 Moggi에 의해 처음 정의될 때만 해도 비교적 명확한 의미를 가지고 있었다는 것이다.

계산은 어떤 비 순수성을 가진 프로그램 또는 그러한 프로그램을 나타낼 수 있는 표현식을 의미했다. 계산개념은 `T<A>`를 반환하는 표현식이 `A`를 반환하는 계산을 나타내는 데 쓰일 수 있는 `T`들을 의미했다. 이러한 개념들은 완전히 명확하다고는 할 수 없지만 적어도 은유는 아니다. 그들이 은유라면 '`int`타입은 정수를 나타낸다.' 같은 말들도 다 은유가 된다.

불행히도 Moggi는 그것들의 의미를 그의 논문에서 그리 정확하게 소개하지는 않았다. 그 결과 그것들은 프로그래머들에게 소개되면서 이상한 환상을 만들어냈다. 

후대의 모나드 전도사들은 선구자들이 만들어낸 환상을 결코 극복해내지 못했다. 그들은 어떻게든 그 환상을 더 그럴듯해 보이게 만들기 위해 그들이 아는 것 중 그 환상과 어렴풋이라도 관계가 있어 보이는 모든 것들을 그 환상 위에 덕지덕지 붙였다. 계산이라는 은유는 그렇게 만들어졌다. 모나드는 그렇게 이해될 수 없는 개념이 되었다.



#### 2-5. 계산의 밖

계산개념은 설령 오류 없이 완전히 이해되었다 해도 오늘날 모나드에 대한 설명에서 중요한 역할을 하기는 힘들었을 것이다. 프로그래밍에 쓰이는 유용한 모나드 중에는 Moggi의 계산, 즉 어떤 비 순수성을 가진 프로그램과 무관한 맥락에서 쓰이는 것들도 많기 때문이다.

애초에 모나드가 계산을 나타내는 데 쓰일 수 있었던 건 단지 `T`가 모나드일 경우 `A`에서 `T<B>`로 가는 함수와 `B`에서 `T<C>`로 가는 함수의 합성을 자연스럽게 정의할 수 있기 때문이다. Moggi는 이런 함수들이 비 순수 함수들, 이른바 계산이 되는 경우에 주목했지만 그것이 다른 종류의 확장된 함수를 나타내지 말라는 법은 어디에도 없었다.

계산과 무관한 모나드의 활용은 일반 모나드 사용자들의 코드에서도 쉽게 찾을 수 있다. 아래의 하스켈 코드를 보라.

```haskell
do
	xs <- [2, 3, 5, 7]
	plusminus(xs)  -- [2, -2, 3, -3, 5, -5, 7, -7]
```

리스트 모나드가 계산개념으로써 비결정적인 계산을 나타낸다는 공식적인 설명을 가지고 있는 것은 사실이다. 이 해석을 따르고자 하는 이들은 위 코드를 이렇게 해석할 것이다: 2도 3도 5도 7도 될 수 있는 비결정적인 값을 비결정적인 계산을 수행하는 함수 `plusminus`에 넣어 비결정적인 결과값을 얻었다. 그러나 이 해석은 정말로 타당한 것인가?

현장에서 `List`모나드를 활용하는 누구든 찾아가서 물어 보라. 이건 그냥 조건에 맞는 값 여러 개를 반환하는 함수에 여러 값을 보내 여러 개의 결과값을 얻는 코드라고 할 것이다. 비결정성 어쩌고는 나쁜 이론가의 상상 속에만 존재하는 군더더기일 뿐이다.

위 예제에서 실제로 합성되고 있는 것은 '조건에 맞는 값 여러 개를 반환하는 함수' 다. 문제는 그것이 Moggi의 계산에 속하지 않는 전혀 다른 종류의 확장된 함수라는 것이다.<a href="#F7">[7]</a> 계산을 아주 넓은 의미로 해석한다면 그것조차 계산이라고 할 수 있겠지만 그런 해석이 위 예제를 이해하는 데 도움이 될지는 다른 얘기다.

이론이 아닌 경험을 통해 모나드를 배운 후발주자들은 대부분 모나드를 계산이나 비 순수성과 연결짓지 않았다. 그들 중 일부는 계산개념에 기반한 공식적인 설명과 완전히 다른 자신만의 모나드 설명을 만들어냈다. 

물론 후발주자들의 이해는 많은 경우 부정확하거나 불완전했고, 때로는 심각한 오류까지 담고 있었다. 그들의 설명 대부분은 이론가들의 것보다 더 나빴다. 이론가들은 흔히 이들의 한심한 모나드 설명을 비난했다. 그러나 애초에 이론가들 자신의 설명이 현실과 맞지 않았기 때문에 후발주자들이 다른 설명을 만들어낼 수밖에 없었다는 사실은 거의 인식되지 못했다. 

여하튼 모나드를 계산이나 비 순수성하고만 연결짓는 설명은 이미 시대에 뒤쳐진 것이다. 그것은 모든 모나드는 고사하고 모든 유용한 모나드조차 설명하지 못한다. 아직도 많은 모나드 전도사들이 그러한 설명이 작동할 거라고 믿는다는 것은 놀라운 일이다.



#### 2-6. 모나드는 무엇을 나타내는가?

그러나 계산조차 아니라면 무엇을 가지고 (유용한) 모나드를 설명해야 하는가? 

프로그래밍의 (유용한) 모나드는 계산개념이었을 때도 충분히 경계가 모호하고 불분명했다. 이제는 그 설명조차 불충분했다. 그 거대한, 무한히 꾸물거리며 퍼져나가는 부정형의 괴물을 정제된 언어의 틀 안에 가두는 건 불가능해 보였다.

방법이 없지는 않았다. 다음 설명은 명확하고 완비적이며 모나드에 대한 설명 치고는 놀라울 만큼 이해하기도 쉽다. 

- 모나드는 `A`에서 `T<B>`로 가는 함수가 `A`에서 `B`로 가는 함수를 기능적/의미론적으로 확장한 것으로 해석될 수 있는 모든 타입 컨스트럭터 `T`이다.

그러나 어쩌면 프로그래밍의 모나드에 대한 유일하게 정확한 설명일지도 모르는 이 설명은 영원히 발견되지 않았다. 단지 우발적으로 그것을 반환하는 함수가 계산으로 해석될 수 있었을 뿐인 `T`들 속에 실제로 계산의 개념이 있다고 믿은 선구자들처럼, 이후의 모나드 전도사들도 단지 우발적으로 그것을 반환하는 함수가 확장된 함수로 해석될 수 있었을 뿐인 타입 컨스트럭터들 속에 그들이 잘 모르는 어떤 공통적인 의미가 있을 거라고 믿고 그것을 찾으려고 애썼다.

프로그래밍의 모나드에 관한 영문 위키피디아 페이지<a href="#F8">[8]</a>는 아마 정상적인 사람들의 눈에는 거의 확실히 횡설수설처럼 보일 C. A. McCann의 이 설명을 인용하고 있다.

> For a monad 'm', a value of type 'm a' represents having access to a value of type 'a' within the context of the monad.<a href="#F9">[9]</a>
> (모나드 'm'에 대해 'm a' 타입의 값이란 그 모나드의 맥락에서 'a' 타입의 값에 접근할 수 있는 것들을 나타낸다.) 

물론 맥락이 어쩌고 하는 모나드 설명은 McCann이 2010년에 위 글을 작성하기 훨씬 전부터 존재했다. 그것은 서로 다른 수 많은 모나드 안에서 무언가 공통적인 의미를 찾으려고 한 모나드 전도사들의 가망 없는 노력의 결과 중 하나였다. 그것은 오직 맥락이라는 말 자체가 워낙에 모호해서 아무 모나드에나 다 끼워맞출 수 있었기 때문에 작동했다. 물론 맥락이라는 말 자체가 워낙에 모호해서 모나드가 아닌 것들도 다 끼워맞출 수 있었기 때문에 그것은 애초에 모나드를 모르는 사람에게는 완전히 무용지물이었다.

나는 여기서 모나드 전도사들이 모나드를 한 마디로 설명한답시고 만들어낸 모든 헛소리들을 다 다루지는 않을 것이다. 명확한 말로 모나드를 설명하는 것이 불가능했기 때문에 그 설명들은 의도적으로 최대한 애매하고 불분명하게 만들어졌다. 모나드를 이미 이해한 사람들은 그 말들이 전달하고자 하는 것을 느낌으로 어느 정도 알아들을 수 있었다. 그러나 그렇지 않은 사람들에게 그것들은 철저하게 무의미했다. 



#### 2-7. 재앙의 시작

모나드는 빠르게 함수형 프로그래밍의 새로운 핵심 개념으로 자리잡았다. 모나드 튜토리얼들의 범람은 필연적이었다. 뉴비와 구루를 가리지 않고 수 많은 사람들이 모나드를 쉽게 가르쳐준다고 하는 이 유망한 새로운 사업에 뛰어들었다. 

문제는 그것을 어떻게 가르쳐야 하는가였다. 분명 모나드는 `>>=`와 `unit`을 가진 타입 컨스트럭터라는 그것의 형식적인 정의를 아는 것만으로는 만족스럽게 이해할 수도, 써먹을 수도 없었다. 그것을 진정으로 이해시키기 위해서는 무언가 다른 것이 필요했다.

모나드의 의미를 둘러싼 신비한 횡설수설들은 실제로 모나드를 이해하는 데는 아무 도움이 되지 않았지만 모나드에 그것의 형식적 정의 이상의 의미가 있다는 것 하나만큼은 확실히 말해 주고 있었다. 대부분의 프로그래머들이 바로 거기에 그들이 모나드를 이해할 수 있게 할 단서가 있을 거라고 믿은 것은 당연했다. 타입이 어떤 의미를 가진 대상을 나타낼 경우 그 의미를 이해하는 것이 구현을 이해하는 것보다 더 중요하다는 것은 프로그래밍을 배운 사람이라면 누구나 알고 있는 상식이다.

모나드를 배우려 온 사람들은 흔히 다음과 같이 물었다. 

'모나드는 무엇인가?'

물론 이 질문은 모나드의 형식적 정의에 관한 것이 아니다. 그들은 모나드가 현실의 어떤 추상적 개념을 표현한 것인가를 묻고 있었다. 문제는 아무도 이 질문의 정확한 답을 알지 못했다는 거였다. Wadler같은 고대구루들마저 그걸 알지 못해서 횡설수설하는 판에 후대의 모나드 전도사들이 그걸 대답할 수 있을 리는 만무했다.

그럼에도 불구하고 우리가 모나드를 이해할 수 있는 단서는 바로 그 질문에 있다고 믿어졌고, 당연히 많은 모나드 튜토리얼들도 그 질문에 초점을 맞췄다. 선배들이 만들어낸 계산이니 맥락이니 하는 종잡을 수 없는 횡설수설들을 그대로 반복하는 부류는 차라리 나았다. 그러한 설명이 비실질적이고 난해하다고 느낀 일부는 다른 것을 시도했다. 자신이 직접 모나드를 써 보며 느낀 모나드가 무엇인가에 대한 어렴풋한 감각을 알기 쉬운 비유로 전달하는 것이 그것이었다.

훗날 모나드 튜토리얼 전체를 조롱거리로 전락시킨, 모나드에 대한 가장 어리석은 설명들은 이렇게 만들어졌다.



## 3. 위기 - 엇나간 질문

#### 3-1. 이해를 이해하기

'모나드는 무엇인가?' 라는 질문은 물론 잘못된 것이다. 나중에는 거의 모든 사람들이 그것을 이해했다. 문제는 올바른 질문이 무엇인가다. 

어떤 사람들은 그 질문이 '모나드는 프로그래밍에 어떻게 활용하는가?' 라고 믿는다. 나는 회의적이다. 모나드를 정의와 활용만 가지고 설명하려 한 시도들은 이미 셀 수도 없을 만큼 많다. 모나드를 설명하는 방법 중 가장 먼저 시도된 것이 그것이었다. '모나드는 무엇인가?' 에 대한 대중의 집착은 오히려 그것이 성공적이지 못했다는 사실의 결과였다.

그렇다면 올바른 질문은 무엇인가? 어떤 질문이 모나드와 같은 추상적인 개념을 진정으로 이해하게 하는가?

어쩌면 모나드는 이런 근본적인 질문을 다루기에는 그리 좋은 소재가 아닐지도 모른다. 그것은 너무 크고 복합적이다. 같은 질문을 더 작은 규모에서 다룰 수 있게 해 주는 좋은 예가 있다. 하스켈의 `do`, 스칼라의 `for` 같은 모나드 전용 문법들이 바로 그것이다. 

'그것은 어떻게 사용하는가?' 관점을 가진 이들에게 이 문법들은 아주 설명하기 쉬워 보였다. 모나드 전용 문법들은 다소 복잡하지만 외우기 힘들 정도는 아니다. 필요한 것은 독자들이 그 문법들에 익숙해질 수 있도록 충분히 많은 활용 예제를 보여 주는 것 뿐이다. 프로그래밍 언어의 문법을 설명하는 데 정의와 활용 말고 다른 무엇이 필요하겠는가?

그러나 예상치 못한 일이 일어났다. 독자들은 모나드 전용 문법의 형식적인 정의와 각 활용 예제들은 잘 이해하는 듯했다. 이상한 건 그 이후다. 

독자들은 그들이 그 문법들을 진정으로 이해했다고는 결코 생각하지 않았다. 그들은 계속해서 무언가가 이해가 가지 않는다고 말하곤 했다. 무엇이 이해가 가지 않는 건지는 그들 자신도 몰랐다. 물어 보면 그들은 '이 `do` 표기법의 의미는 무엇인가?' 따위의 어리석은 질문이나 할 뿐이었다.

모나드 튜토리얼의 저자들은 기회가 있을 때마다 '`do` 표기법은 단지 문법 설탕일 뿐이다' 같은 것을 말하며 독자들의 그런 무의미한 의문을 차단하기 위해 최선을 다했다. 그러나 그 노력이 성과를 거두는 일은 없었다. 독자들은 명백히 그들이 그 설탕을 이해하게 해 줄 다른 무언가를 요구하고 있었다. 문제는 그 무언가가 무엇이냐는 것이다.



#### 3-2. 이해는 필연성을 발견하는 것이다

답은 명백하다. 나는 이 문제에 대해 한 번이라도 진지하게 고찰해 본 사람이라면 다른 결론을 내리는 것이 불가능할 거라고 믿는다. 독자들에게는 그 설탕이 충분히 *개연적인* 것으로 보이지 않았다. 그들이 원했던 건 그 개연성을 채워 줄 무언가였다. 그들은 프로그래밍의 관점에서 그 설탕이 왜 충분히 만들어질 만한 것이었는지에 대한 설명을 요구하고 있었던 것이다.

`do` 표기법과 `for` 형식을 이루는 규칙들은 복잡하다. 그것은 외우기 힘들 만큼 복잡하지는 않다. 그러나 그것의 동기와 배경을 추측하는 것이 거의 불가능하게 할 만큼은 충분히 복잡하다. 

그러한 문법들이 코드를 더 짧고 직관적으로 만들어 준다는 건 사실이다. 문제는 그 원리다. 그것은 왜 유용한가? 그것은 *왜 그렇게 기묘하게 정의되어야* 유용한가? 그 문법들 가지고 축약할 수 있는 건 람다 정의와 `>>=` 가 중첩된, 의미가 잘 와닿지 않는 특정 패턴의 코드들 뿐이다. 그런 코드들이 자주 사용될 거라는 것을 어떻게 아는가? 설계자들은 어떻게 그것을 알고 그 문법들을 그렇게 만든 것인가? 우연히? 그런 것이 우연히 발견될 수도 있는 것인가? 

물론 아니다. 독자들은 그 문법들의 이면에 무언가 설명되지 않은 것들이 있음을, 바로 거기에 그들이 그 문법들을 진정으로 직관화하게 해 줄 단서가 있음을 느꼈다. 단지 그들은 그것을 어떻게 물어 봐야 할지 몰랐을 뿐이다. 그들의 무의미해 보이는 질문들은 이런 사정의 결과였던 것이다.

그들의 불만족감을 해소해주는 방법은 간단하다. 그들이 원하는 것을 제공하면 된다: 그러한 문법들이 왜 만들어져야 했는지, 만들어지더라도 왜 하필 우리가 아는 그 형태로 만들어져야 했는지로 이어지는 필연적인 논리의 사슬.

그것을 제공하는 것은 물론 어렵다. 그러나 불가능한 일은 아니다. [모나드에 대한 작동하는 설명](I-2.md)은 가능한 방법 중 하나를 보여 준다. 우선 그것은 다음과 같은 질문을 던진다: 변수가 여러 개인 계산들은 `(A, B)->T<C>` 타입의 이변수 함수, 또는 그것을 커링한 `A->B->T<C>`타입의 함수로 나타낼 수 있을 것이다. 이들을 `T<A>`, `T<B>`를 반환하는 다른 계산들과 합성해야 한다고 하자. 어떻게 하면 되는가?

답은 곧 밝혀지지만 그리 간단하지는 않다. 다변수 계산들을 이용할 때마다 매번 그런 조작을 하는 건 아무래도 번거롭다. 무엇보다 상황을 불만족스럽게 만드는 것은 결코 답의 논리 자체가 어려운 것이 아니라는 것이다. 우리는 직관적으로 독립적인 두 변수 `x`와 `y`가 포함된 식을 필요에 따라 `x`의 함수로 보고 조작하는 일을 할 수 있지만 프로그래밍 언어의 문법은 그렇지 않다. 프로그래밍 언어로 같은 일을 하려면 매번 식을 감싸는 함수를 직접 정의해야 한다. 그것이 다변수 계산의 합성 코드를 불필요하게 복잡하게 한다.

어떻게 하면 이 문제를 해결할 수 있을까? 한 가지 방법이 있다. 우리의 직관적인 사고 논리를 더 잘 나타내 주는 새로운 문법을 도입하는 것이다. 하스켈의 `do`, 스칼라의 `for`와 같은 모나드 전용 문법들이 바로 그것이다.

모나드 전용 문법들은 상술한 '`x`와 `y`가 포함된 식을 `x`의 함수로 보고 조작하는' 과정을 자동화한다. [모나드에 대한 작동하는 설명](I-2.md)은 가상적인 적분 전용 문법과 그것을 비교함으로써 그것이 왜 다변수 조작에 대한 우리의 직관 논리를 더 자연스럽게 표현하는지 가르쳐 준다. 결국 몇개의 예제를 보여 줘도 do 표기법을 이해하지 못한 이들을 이해하게 한 것은 이 설명이었다.

다른 추상적인 개념들을 설명할 때도 마찬가지다. 얼마나 많은 이들이 양자역학을 배우면서, 수반(adjunction)과 같은 수학 개념을 배우면서 무언가가 이해되지 않는다는 어려움을 호소하는지 보라. 그들도 늘 비슷한 무의미한 질문을 던진다. '이 법칙은 왜 성립하는 것인가?' 등등. 

교단에 선 이들은 기회가 있을 때마다 '이것은 그냥 자연 법칙일 뿐이다', 또는 '그냥 개념의 정의가 그럴 뿐이다' 같은 말들을 되풀이하며 학생들의 무의미한 의문을 차단하기 위해 최선을 다했다. 그러나 그 노력이 성과를 거두는 일은 없었다. 학생들은 명백히 그들이 그 정의를 이해하게 해 줄 다른 무언가를 요구하고 있었다. 문제는 그 무엇이 무엇이냐다.

일견 무의미해 보이는 그 질문들을 통해 학생들이 진정으로 묻고 있는 것은 무엇일까? 언제나 같다. '이 개념들은 왜 이런 형태로 만들어져야 했는가?' 다. 

우리가 어떠한 추상적인 개념을 이해하는 건 그것의 정의를 알았을 때가 아니다. 그것이 왜 그런 정의를 가져야 하는지 설명할 수 있게 되었을 때다. *궁극적으로 우리는 그 개념의 창시자와 동격의 자리에 서서 그 개념을 필연적으로 만들어야 했던 그의 동기와 사고를 이해하기를 원한다.* 그것을 할 수 없을 때 우리는 우리가 그 개념들을 이해하지 못했다고 느끼는 것이다.

오늘날 나쁜 강의를 일삼는 이들의 가장 큰 문제는 그들이 정확히 무엇을 가르쳐야 하는지 모른다는 데 있다. 이해는 언제나 무언가의 필연성을 발견하는 것이다. 특히 모나드처럼 추상적인 대상에 대한 강의는 그것을 전달하지 못하면 절대로 작동하지 않는다.



#### 3-3. 은유 기반 튜토리얼들

본격적인 모나드 튜토리얼의 시대가 열린 후 그 사업에 뛰어든 후발주자들은 모나드를 이해하는 것이 단지 그것의 정의를 아는 것과는 다르다는 것은 알았다. 그것을 이해하려면 다른 무언가가 필요했다. 문제는 그것이 무엇이냐였다.

그들은 그들이 직접 모나드를 써 보면서 얻은 모나드가 무엇인가에 대한 어렴풋한 감각에 집착했다. 그들의 관심사는 명확한 말로는 잘 표현되지 않는 그 감각을 어떻게 전달할 것인가였다. 그들은 누구나 이해할 수 있는 쉬운 은유에 그 비결이 있다고 믿었다. "계산" 같은 추상적이고 이해하기 힘든 해석이 아닌, 쉽게 시각화할 수 있는 사물들을 이용하는 쉬운 은유에.

Eric Kow의 Of monads and spacesuits<a href="#F10">[10]</a>는 그러한 시도의 전형적인 사례다. 여기서 저자는 값을 우주 비행사에, 함수를 우주 정거장에 비유한다. 

> Imagine that we are in some vast expanse of space. Scattered throughout space are a bunch of space stations. A space station is just a metaphor for a function: it takes astronauts in, and spits astronauts out.
> (우리가 어떤 광대한 우주 공간에 있다고 상상해 보라. 우주 도처에는 우주 정거장들이 흩어져 있다. 우주 정거장은 단지 함수를 은유적으로 나타낸 것에 지나지 않는다. 그것은 우주 비행사를 들여보내고 우주 비행사를 뱉어낸다.)

모나드는 우주복에 비유된다. 모나드 타입을 반환하는 함수들은 우주 비행사를 그냥 내보내는 대신 우주복으로 감싸서 내보내는 우주 정거장과 같다.

> ... The solution here would be to stick the astronaut into some kind of space suit before sending him or her to the next station. In fact, this is such a good solution, and we the people are so concerned about the well-being of our astronauts that we're going to issue a new directive: All space stations must put their astronauts into space suits before sending them out.
> (... 해결책은 우주 비행사를 다음 우주 정거장에 보내기 전에 일종의 우주복으로 감싸는 것이다. 이것은 너무나 좋은 해결책이며, 우리는 우주 비행사의 안전에 대해 매우 신경쓰고 있으므로 우리는 새로운 법률을 제정할 것이다: 모든 우주 정거장은 우주 비행사들을 우주에 내보내기 전에 우주복으로 감싸야 한다.)

문제는 이 우주 정거장들이 입력으로는 우주복을 입은 우주 비행사를 요구하지 않는다는 것이다. 입력으로 사용되는 건 여전히 그냥 우주 비행사다. 이 정거장들을 합성하려면 어떻게 해야 할까? 저자는 bind라는 특수한 로봇을 소개한다.

> ... what we're going to do is create a kind of robot that takes a space suit (containing some astronaut), takes a space station, removes the astronaut from its suit and feeds the naked astronaut to the space station. This robot shall be called bind informally but will be written in Haskell as >>=.
> (... 우리가 하려 하는 일은 우주복을 입은 우주 비행사와 우주 정거장이 주어지면 우주 비행사로부터 우주복을 벗겨낸 뒤 벌거벗은 우주 비행사를 우주 정거장에 넣는 특수한 로봇을 만드는 것이다. 이 로봇은 비공식적으로는 bind라고 불리지만 하스켈에서는 >>=로 씌여진다.)

대부분의 사람들은 아무래도 떠오르는 의문을 참을 수 없을 것이다. 왜 그냥 우주 정거장을 출력으로도 입력으로도 우주복을 입은 우주 비행사를 이용하도록 설계하지 않는가? 현실의 우주 정거장들은 그렇게 설계될 것이다. 프로그래머들은 정신병자들 또는 동료 프로그래머들을 고문하기를 좋아하는 새디스트들인가? 모나드가 그냥 우주복 같은 것이라면 왜 그들은 굳이 그것을 값을 반환할 때만 사용하고 입력할 때는 사용하지 않음으로써 번거로운 로봇 없이는 함수들을 합성할 수조차 없게 하는가?

물론 프로그래밍에 모나드 타입을 반환하는 함수들이 사용되는 건 그들이 '실패할 수 있는 함수' 나 '부작용을 가진 함수' 등의 고유의 의미를 갖기 때문이다. 문제는 그것을 모르는 이들이 저자의 튜토리얼을 읽고 그것을 알 방법이 있느냐다. 우주 정거장들이 우주 비행사에 우주복을 입히는 건 그게 우주 정거장에 무슨 새로운 의미를 제공해서가 아니다. 우주 비행사의 안전을 위해서다. 정작 중요한 핵심적인 부분의 논리는 전혀 모나드의 그것과 대응되지 않는 이런 억지 은유가 정말 모나드 초보자들에게 도움이 될까? 혼란만 가져다주지 않을까? <a href="#F11">[11]</a>

저자의 은유는 점점 더 혼란스러워진다. 우주복이 비어 있을 수 있는 `Maybe` 모나드와 우주복에 우주 비행사가 여러 명 타고 있을 수 있는 `List` 모나드를 소개한 뒤, 그가 다음으로 소개하는 것은 글에 명확히 설명되지 않는 어떤 이유로 '함수 실행과 동시에 일부 정보를 전달해야 할 때 유용하다'고 주장되는 `State` 모나드다. 이 우주복에 대한 그의 묘사는 이렇다.

> ... in State space, the space suits are very sophisticated: all space suits have a ticket reader, and when you feed a ticket (st) into the space suit, it opens up to reveal an astronaut and ticket (a, st).
> (State 우주에서 우주복은 매우 정교하다. 모든 우주복에는 티켓 입력기가 달려 있으며 티켓(st)을 우주복에 넣으면 열려서 우주 비행사와 티켓 (a, st)을 드러낸다.)

불행히도 이 우주복을 우주 정거장에 연결하는 `bind` 로봇에 대한 저자의 설명은 거의 이해가 불가능하다. 내가 이해한 것이 옳다면 그것은 아무런 합리적인 이유도 없이 우리가 처음부터 가지고 있다고 가정되는 어떤 티켓을 주어진 우주복에 넣은 후, 우주 비행사와 새 티켓이 얻어지면 그 중 우주 비행사를 주어진 우주 정거장에 보내고, 갑자기 어떤 '컨테이너 우주복' 을 만드는데 그 컨테이너 우주복에는 우주 비행사가 아니라 티켓이 주어지면 앞에서 설명한 전체 과정을 수행하는 '루브 골드버그 장치 (Rube Goldberg contraption)' 같은 것이 들어 있다. <a href="#F12">[12]</a>

우리가 앞에서 본 것은 일반적인 `State` 우주복에 대한 묘사 아니었는가? `State` 우주복을 우주 정거장에 `bind` 했을 때 얻어지는 건 `State` 우주복이어야 한다. 왜 전혀 달라 보이는 '컨테이너 우주복' 이란 것이 얻어지는가? 그 컨테이너 우주복도 `State` 우주복인가? 그런 것도 우주복의 범주에 드는가? `State` 우주복은 정말로 무엇인가?

모르겠다. 더 큰 문제가 있다. 저자의 약속은 분명 모나드의 원리를 시각화해서 이해하기 쉽게 하는 것이었다. 이런 괴상한 걸 어떻게 시각화한다는 말인가? 설령 시각화한다 한들 자체로 이미 모나드보다 더 이해하기 힘든 그 이미지가 정말 모나드의 이해에 도움이 되기는 할까?



#### 3-4. 아무것도 아닌 것을 위한

모나드를 처음 배우는 사람이 어떤 기적에 의해 Eric Kow의 은유를 이해했다고 치자. 그는 무엇을 얻은 것인가? 그 은유는 무엇을 가르쳐 주는가?

저자는 그의 은유가 오직 모나드가 내부적으로 어떻게 작동하는지에 관한 것이며 모나드를 어떻게 사용하는지나 그것이 왜 그렇게 만들어졌는지 등의 다른 질문에 답하기 위한 것은 아님을 비교적 솔직하게 밝힌다.

> I do not actually explain how to use monads. Instead I mainly focus on how they work. Perhaps the best people to read this page are those who have some vague idea how to manipulate monadic code but would really like to know what's going on under the hood. I also do not explain why certain conceptual choices are made, preferring instead to short circuit this by use of the space station metaphor.
> (나는 모나드를 어떻게 사용하는지 설명하지는 않을 것이다. 대신 나는 그들이 어떻게 작동하는지에 초점을 맞추고 싶다. 어쩌면 이 글을 읽기 가장 좋은 사람들은 모나드 코드의 조작 방법에 대한 대강의 개념은 가지고 있지만 장막 아래에서 실제로 어떤 일이 일어나는지 알고 싶어하는 사람들일 것이다. 나는 왜 특정한 개념적 선택이 이루어졌는지 설명하는 대신 우주 정거장의 은유를 통해 그 문제를 피해 갈 것이다.)

이것이 정말로 모나드 초보자들에게 도움이 될까? 저자는 모나드를 대강 알지만 그것을 이해하지는 못한 수 많은 모나드 초보자들의 문제가 단지 그것의 작동 방식에 대한 무지 또는 불완전한 직관화에 있다고 믿는 것으로 보인다. 그것은 정말로 옳은가?

물론 아니다. 모나드 초보자들이 흔히 겪는 혼란스러운 느낌은 언제나 그것이 왜 그렇게 만들어져야 했는지에 대한 무지의 결과다. 

모나드에 대한 Eric Kow의 은유가, 그리고 그와 유사한 다른 모든 은유가 아무 쓸모가 없을 수밖에 없는 이유가 바로 여기에 있다. 모나드 초보자들이 그 은유들을 이해해도 그들의 모나드에 대한 의문은 조금도 줄어들지 않을 것이다. 설령 모나드가 우주복 같은 거라고 쳐도, 도대체 그런 게 왜 필요하다는 말인가? 

독자들은 이미 내가 전통적인 "계산" 해석에 결코 관대하지 않다는 것을 알 것이다. 모나드 프로그래밍의 관점에서 "계산" 의 의미는 명백하다: 순수하지 않은 연산. 그것을 나타내는 것은 모나드 타입을 반환하는 함수 또는 표현식이다. 모나드 자체가 아니다.

전통적인 "계산" 해석을 지지하는 이들은 `unit`과 `>>=`를 가진 타입 컨스트럭터와 결합된 모든 타입의 의미를 포괄하는 직관적인 "계산" 의 개념이 존재한다고 믿는다. 그런 믿음은 터무니없는 것이다. 억지로 그렇게 계산을 재정의할 수는 있다. 문제는 그 정의를 직관적으로 정당화할 수 있느냐다. 지난 20년 동안 모나드 전도사들은 그 정의를 정당화하기는커녕 그것을 난해한 용어나 황설수설 없이 설명할 방법조차 찾지 못했다. 

그럼에도 불구, 뒤틀린 "계산" 개념에 기반한 해석은 이해하는 것이 어려울지언정 무의미하지는 않았다. 비록 정합적인 언어로 표현될 수 없는 것이었다고는 하나 어떻게든 (주로 독자 자신의 모나드에 대한 축적된 경험을 통해) 그 "계산" 을 이해한 이들은 모나드도 이해했다. 그것은 자체로 왜 모나드라는 개념이 존재해야 하는가에 대한 답이었다.

후발주자들의 은유는 완전히 달랐다. 모나드가 대충 무엇인가에 관한 한 그것은 얼추 잘 작동하는 듯했다. 문제는 뒤틀린 "계산" 에 거의 버금갈 만큼 이해하기 어려운 그것들에 대한 이해가 결코 모나드 자체에 대한 이해를 가져다 주지는 않았다는 것이다. 

모나드가 상자나 부리또, 또는 핵폐기물 차폐용기와 같다는 것을 안 후에도 사람들은 여전히 의문을 느꼈다. '이런 상자나 부리또 같은 건 왜 존재하며 왜 다들 이걸 가지고 난리를 치는 것인가?' 그 의문의 크기는 그들이 애초에 모나드를 처음 접했을 때 느꼈던 '모나드가 무엇인가?' 라는 의문의 크기보다 컸으면 컸지 결코 작지 않았다. 

완전히 아무것도 아닌 것을 위한 압도적인 노력의 낭비. 그것이 당시의 모나드 전도사들이 앞다투어 만들어낸 여러 무의미한 은유들의 본질이었다.



#### 3-5. 컨테이너라는 은유

오늘날까지도 많은 사람들이 계산과 함께 모나드에 대한 양대 해석 중 하나로 여기는 컨테이너라는 은유도 마찬가지다. 그것은 모나드에서 진정으로 이해되어야 하는 것이 무엇인지조차 몰랐던 이들이 만들어낸 또 하나의 실패작에 지나지 않는다.

컨테이너는 물론 앞에서 본 우주복 등의 다른 은유들처럼 특정 측면에서만 모나드와 유사한 대상은 아니다. 모나드는 단지 컨테이너와 비슷한 것이 아니라 컨테이너라고 주장되었다. `Optional`과 `List`는 당연히 컨테이너이며 `Reader`나 `State`, 심지어 `IO`도 어떤 관점에서는 컨테이너라고 볼 수 있었다. 

문제는 그 어떤 관점으로써 허용되는 관점의 범위가 어디까지인가다. 모나드가 컨테이너라는 말은 기껏해야 두리뭉실했다. 

당신이 컨테이너 해석을 통해 모나드를 처음 배우는 사람이라고 생각해 보라. 처음에는 모든 게 쉬워 보인다. `Optional<A>`도 `List<A>`도 명백히 `A`의 컨테이너이므로. 불행히도 그 느낌은 오래 가지 못한다. 새로 배우는 모나드 전부가 당신을 놀라게 한다. `Reader<E, A>`가 어떻게 `A`의 컨테이너인가? `Writer<W, A>`는? `State`와 `Cont`, `IO`모나드 타입의 값들은 어떻게 컨테이너가 되는가?

물론 그것들도 컨테이너라고 보는 것이 불가능하지는 않다. `Reader<E, A>`는 가능한 모든 `E`타입의 값에 `A`타입의 값 하나를 대응시키는 연관 배열로 볼 수 있으며 그것은 컨테이너다. `Writer<W, A>`는 `A`타입의 값과 함께 `W`타입의 부가정보도 함께 가지고 있는 컨테이너다. 기타 등등.

문제는 이러한 설명들이 본질적으로 아리송해서 도대체 어디까지가 `A`의 컨테이너고 어디서부터가 아닌지에 대한 의문을 불러일으킨다는 것이다. `A`의 컨테이너가 꼭 `A`타입의 값만 담고 있어야 하는 것도 아니고 애초에 꼭 `A`타입의 값을 담고 있어야 하는 것도 아니라면 세상에 `A`의 컨테이너라고 부를 수 없는 것이 어디에 있는가?

어떻게든 모나드가 컨테이너임을 받아들인 후에도 의문은 남는다. 그런 애매하고 두리뭉실한 컨테이너 개념은 왜 필요한 것인가? 

물론 `bind`함수는 `List`를 비롯한 많은 컨테이너에 유용한 기능을 제공한다. 그러나 컨테이너에 대해 그것은 기껏해야 제한적일 쓰임새만 가질 뿐이다. 일반적인 컨테이너에 대해 유용한 건 `lift`또는 `map`함수다. 그리고 컨테이너가 그것을 갖기 위해 꼭 모나드가 되어야 하는 것은 아니다. 

요컨대 모나드가 컨테이너라는 해석은 적어도 단독으로는 모나드가 왜 만들어졌는지, 왜 많은 프로그래머들이 그것에 주목했는지에 대한 그럴듯한 설명을 전혀 해 주지 못한다. 문제는 그것들이 우리가 모나드를 이해하기 위해 답해야 하는 가장 중요한 질문들이라는 것이다.



#### 3-6. 발견되지 않은 대안

컨테이너 해석이 무언가 의미있는 일을 하기는 한다. 그것은 독자들에게 대강 어떤 것들이 모나드가 되는지에 대한 어렴풋한 느낌을 준다. 모나드에 대한 다른 은유들도 마찬가지다. 

문제는 은유가 적어도 그것을 위한 최선의 수단이기는 했는가다.

앞에서 나는 모나드의 본래 정의가 '스스로를 정당화하기 충분할 만큼 자연스럽다.' 고 말한 바 있다. 정말로 그렇다. 모나드는 그냥 `unit`과 `join`만 추가로 더 가진 `Functor`다. `A`타입을 `T<A>`타입으로 바꾸어 주는 함수와 `T<T<A>>`타입을 `T<A>`타입으로 바꾸어 주는 함수. `T`가 추가로 가지고 있을 만한 함수로써 이 둘보다 더 그럴듯한 것이 어디 있는가?

`Functor`는 정의도 쓰이는 이유도 모나드보다 훨씬 설명하기 쉽다. 그것은 `lift`, 또는 동치인 `map`함수를 가진 타입 컨스트럭터를 통칭한다. `map`이 프로그래밍에 얼마나 유용한 함수인지는 굳이 말할 필요도 없을 것이다. 그것을 가진 타입 컨스트럭터에 가장 있을 법한 함수 두 개만 추가하면 그게 바로 모나드인 것이다.

이 정의는 단지 그럴듯하기만 한 것이 아니다. 그것은 모나드에 대한 훨씬 더 좋은 의미론적 해석의 기초다. [모나드에 대한 작동하는 설명](I-2.md)에서 나는 그것을 다음과 같이 묘사한 바 있다.

'모나드는 개념에 대해 한 번만 유효한 의미의 확장이다. 개념 `A`에 대해 `A`도 `T<A>`로 볼 수 있고 `T<T<A>>`도 `T<A>`로 볼 수 있는 `T`가 곧 모나드다.' <a href="#F13">[13]</a>

가령 `Optional`이 왜 모나드일까? 간단하다. 그것은 `A`를 '`A`또는 아무것도 아닌 것' 이라는 더 넓은 개념으로 확장시킨다. 물론 그 확장은 한 번만 유의미하다. '`A` 또는 아무것도 아닌 것 또는 아무것도 아닌 것' 은 '`A` 또는 아무것도 아닌 것' 과 마찬가지이므로. 

모나드가 컨테이너니 맥락이니 하는 어디에든 끼워맞출 수 있는 해석들과 달리 이 해석은 명료하다. 그것은 우리가 실제로 모나드와 모나드가 아닌 것을 구분할 때 쓸 수 있는 직관을 준다.

더 중요한 것은 그것이 모나드 전도사의 주관적인 경험 대신 정의에 기반을 두고 있다는 것이다. 우리는 그 해석과 모나드의 (본래) 정의를 따로 이해할 필요가 없다. 둘은 함께 이해된다. 그 해석은 우리가 모나드의 정의를 직관화하는 것을 돕는다. 모나드의 정의는 그 해석이 정확히 어떤 맥락에서 사용되어야 하는지, 그것이 어떤 가정을 바탕에 깔고 있으며 언제 틀릴 수 있는지 가르쳐 준다.

어떤 이들은 물어볼 것이다. 그것은 너무 어렵지 않은가? 적어도 우주복 같은 것들은 쉽게 시각화할 수 있는 사물들이다. 어떤 조건을 만족하는 개념의 확장은 너무 추상적이지 않은가?

모나드에 관심을 가질 정도의 프로그래머들이 고작 이 정도의 해석을 어려워할 거라는 걱정은 조금 우스꽝스러워 보이기도 한다. 그러나 그들에 의하면 그것은 그들의 경험이 준 지혜다. 그들은 말한다: 모나드 튜토리얼의 독자들은 상상 이상으로 멍청하다. 그들은 조금이라도 추상적인 것은 아무리 쉽게 설명해줘도 알아듣지 못한다. 나도 직접 모나드 튜토리얼을 만들어 보고 그것을 배웠다. 기타 등등. 

그런가? 물론 그들의 튜토리얼들이 실패하기는 했을 것이다. 문제는 그들이 그 실패로부터 얻은 것이 정말로 올바른 교훈인가다. 그들의 튜토리얼들은 정말로 너무 어렵기 때문에 실패했을까?

십중팔구 그들은 모나드를 이해하는 것이 곧  '모나드는 XX하는 것이다.' 를 아는 것이라고 착각했을 것이다. 그 XX가 독자들이 모나드에 대해 느끼는 아리송함을 사실 티끌만큼도 줄여 주지 못함에도 불구하고 말이다. 당연한 실패 후, 그들은 실망해서 말한다. '이렇게까지 풀어서 설명해 줬는데도 이 간단한 것을 이해하지 못할 수 있다니!' 이것이 모나드 전도사들의 독자들의 멍청함에 대한 집단적인 경험의 실체다. 요컨대 그들은 올바른 것을 설명할 줄 모르는 그들 자신의 멍청함을 독자들의 것으로 착각했던 것이다.

후기 모나드 전도사들의 독자들의 지성에 대한 불합리한 무시는 실패가 항상 올바른 교훈을 가져다 주지는 않는다는 것을 보여 주는 좋은 사례다. 여기서는 그들의 판단보다는 일반인의 상식이 차라리 옳다. 모나드 튜토리얼의 독자들은 바보가 아니다. 그들은 이미 다형성 등의 많은 추상적인 개념에 익숙할 것이다. 그들이 위 해석을 어려워할 거라는 염려는 정확히 보이는 것만큼 우스꽝스럽다.



#### 3-7. 다시 보는 모나드의 새로운 정의

'모나드가 무엇인가?' 가 모나드의 본래 정의를 통해 간단히 답해질 수 있다는 사실은 굳이 그 정의를 훨씬 더 복잡한 것으로 교체한 선구자들의 선택을 다시 한번 돌아보게 한다.

프로그래밍의 모나드가 순수하지 않은 현실의 프로그램을, 이른바 "계산" 을 순수 함수만으로 프로그래밍할 수 있게 하기 위해 도입된 도구라는 것은 옳다. 그 용도를 이해하는 것이 모나드를 이해하는 것의 핵심임은 의심의 여지가 없다.

그러나 모나드의 정의를 굳이 그 용도에 관계된 더 복잡한 것으로 바꿀 필요가 있는가는 다른 문제다. 그것이 정말로 모나드를 쉽게 설명하는 데 도움이 될까? 그 반대가 사실이 아닐까?

당장 대부분의 카테고리 이론 강의가 모나드를 어떻게 설명하는지 보라. 대부분의 강의는 모나드를 간단한 본래 정의를 통해 소개하고 모나드 프로그래밍의 "계산" 에 상응하는 Kleisli 카테고리는 나중에 따로 다룬다. 이 순서를 뒤집어 Kleisli 카테고리를 만들어내는 것으로 모나드를 가르친다고 상상해 보라. 수학과 학생들조차 그런 강의는 어렵다고 할 것이다. 모나드 전도사들은 그런 방법으로 모나드를 가르치고 있는 것이다.

상술했듯이 모나드와 계산의 관계는 기껏해야 간접적이다. `Optional<A>`라는 타입이 아니라, 그것을 반환하는 표현식이 `A`를 반환하는 실패할 수 있는 계산의 의미를 갖는다.  '모나드 타입은 계산을 나타낸다.' 라는 말은 엄밀히 말해 틀렸다. '모나드 타입은 그것을 반환하는 표현식 또는 함수가 계산으로 해석될 수 있는 것을 나타낸다.' 가 옳다. 

문제는 이 간접적인 관계가 정말로 모나드에 대한 필요한 모든 직관을 제공하는가다. 모나드가 그것을 반환하는 표현식 또는 함수가 계산으로 여겨질 수 있는 성질을 가진 타입 컨스트럭터라고 치자. (참으로 복잡하기도 하다.) 그들은 왜 그런 성질을 갖는가? 무엇이 그들이 그런 성질을 갖도록 하는가?

모나드가 단지 우연히 그런 성질을 공유하는 타입 컨스트럭터들의 모임이었다면 이런 질문을 다룰 필요는 없었을 것이다. 문제는 그렇지 않다는 것이다. 그들의 의미 자체에도 공통된 무언가가 있다. 계산과 관계된 모나드의 성질은 그것으로부터 자연스럽게 파생되는 결과라는 것이 더 사실에 가깝다.

주로 이론이 아니라 경험을 통해 모나드를 배운 후발주자들은 그 사실을 알았다. 그들이 그 공통된 무언가를 이해하는 것이 모나드 이해의 핵심이라고 생각한 것은 당연했다. 

그들은 그 무언가의 정확한 정체까지는 알지 못했다. 모든 모나드가 `A`와 `T<T<A>>`를 `T<A>`로 볼 수 있는 `Functor`라는 더 근본적인 사실 대신 그들은 눈에 보이는 그것의 피상적인 결과들에 집착했다. 모나드가 컨테이너 같은 속성을 가진다는 사실, 모나드가 대충 무엇 같거나 무엇 같다는 사실 등이었다. 우리가 본 은유 기반의 모나드 튜토리얼들은 그것을 전달하기 위한 노력이기도 했던 것이다.



#### 3-8. 근본적인 문제

은유 기반의 엉터리 튜토리얼들이 난립하게 된 가장 큰 이유는 물론 얼치기 모나드 전도사들의 '모나드가 무엇인가?' 라는 잘못된 질문에 대한 집착에 있다. 모나드 전도사들이 애초에 이해가 무엇인지 똑바로 이해하기만 했다면 적어도 지금 우리가 본 것 같은 비극은 없었으리라.

그러나 나는 여기에는 보다 근본적인 문제도 있다고 믿는다. 애초에 "계산" 이 단독으로 모나드를 만족스럽게 설명해 줄 수 없다는 것이 바로 그것이다.

이해에 대해 내가 말한 것을 다시 떠올려 보라. 모나드 튜토리얼의 독자들이 원하는 것은 단지 모나드의 정의나 활용에 대한 설명이 아니다. 모나드라는 것이 왜 필연적으로 우리가 아는 그 형태로 존재해야 하는지에 대한 설명이다. 

"계산" 과의 간접적인 관계가 그 설명이 될 수 있을까? 모나드 전도사들은 애초에 그 관계를 제대로 설명해 본 적도 없지만 (우리가 보았듯이 그들은 "계산" 자체를 정합적인 개념으로 정의하지 못했다.) 설령 그렇게 했더라도 독자들은 여전히 의문을 느꼈을 것이다. 그들은 물어볼지도 모른다. 왜 모나드는 하필 그런 기이한 방식으로 계산과 연결되도록 정의된 것인가?

그 이유는 명백하다. 애초에 모나드가 계산을 나타내기 위해 만들어진 것이 아니기 때문이다. 모나드는 `unit`과 `join`을 가진 `Functor`다. 이 사실은 단지 모나드의 뿌리만 설명해주는 것이 아니다. 그것은 모나드가 왜 그렇게 보편적인 구조인지, 왜 우리가 대부분의 "계산" 에 대응되는 모나드를 찾을 수 있는 것인지도 설명해 준다. 이것을 설명하지 않고 어떻게 모나드를 설명한다는 말인가.

우리는 전체 모나드 튜토리얼 비극이 어떻게 생겨났는지에 대한 진상에 거의 도달했다. 그것을 정리해 보자.

모나드는 두 얼굴을 가진 입체적인 개념이다. 그것은 계산을 나타내기 위한 유용한 도구지만 동시에 `unit`과 `join`을 가진 `Functor`이기도 하다. 우리가 진정으로 모나드를 이해했다고 할 수 있게 되는 건 전자나 후자를 이해하게 되었을 때가 아니다. 둘 모두를 이해하고 필요에 따라 마음대로 두 관점 사이를 전환할 수 있게 되었을 때다.

불행히도 모나드 선구자들은 모나드를 계산과 관계된 측면 하나만으로 설명할 수 있다고 믿는 오류를 범했다. 그 결과는 무엇이었는가? 그들은 그 "계산" 개념을 뒤틀어 이해하면서 그들이 설명하고자 한 그 한 측면마저도 제대로 설명해내지 못했다. 

은유에 집착한 후발주자들이 한 일도 정확히 같다. 어느 쪽을 경시하고 어느 쪽을 뒤틀어 다루었는지만 다를 뿐이다. 결국 모나드의 무엇 하나도 제대로 설명하지 못한 채, 그들은 여기저기 예제만 늘어놓고 그들 스스로는 정합적인 언어로 설명할 능력조차 없음이 명확히 입증된 모나드의 어떤 핵심을 독자들이 그 예제들을 보고 알아서 눈치채주기만을 하염없이 바랬다.

이런 튜토리얼들의 실패에 놀랄 필요는 없을 것이다. 높은 곳에서 떨어뜨린 공이 아래로 떨어지는 것이 놀랍지 않다면 그들의 실패도 마찬가지다. 그 튜토리얼들은 실패할 수밖에 없도록 만들어졌다. 실패는 예견된 결과였다.

참으로 놀라운 사실은 전체 함수형 프로그래밍 커뮤니티가 정당한 자연의 섭리에 의해 발생한 이전 모나드 튜토리얼들의 실패를 특별한 설명이 필요한 놀라운 일로 받아들였다는 것이다. 그 설명들은 다른 요소들에 실패의 책임을 돌렸다. 모나드의 근간이 되는 함수형 프로그래밍의 철학에 대한 독자들의 몰이해, 어려운 수학적인 용어의 사용 등이 그것이었다.

훗날 점점 더 많은 사람들에 의해 수용되어 거의 정설처럼 받아들여지게 된 이 사이비 이론들은 모나드 전도사들이 실패의 진짜 이유를 보지 못하도록 효과적으로 그들의 사고를 마비시켰다. 그들이 그 이론들을 더 깊이 신뢰할수록, 그 이론들이 지적하는 문제들을 해결하는 데 많은 노력을 투자할수록 진정한 문제의 해결은 점점 더 요원해졌다.

모든 것이 칠흑같이 어두운 가운데서도 어쩌면 상황이 나아질 수도 있다는 마지막 희망은 그렇게 사라져 갔다. 아래는 바로 그 과정에 대한 이야기다.





## 4. 절정 - 끝없는 실패



## 5. 결말 - 포기와 체념



## 6. 교훈



## 미주

<a name="F1">[1]</a> Moggi, Eugenio. "Computational lambda-calculus and monads." University of Edinburgh, Department of Computer Science, Laboratory for Foundations of Computer Science, 1988.

<a name="F2">[2]</a> Moggi, Eugenio. "Notions of computation and monads." Information and computation 93.1 (1991): 55-92.

<a name="F3">[3]</a> Wadler, Philip. "Comprehending monads." Proceedings of the 1990 ACM Conference on LISP and Functional Programming. 1990.

<a name="F4">[4]</a> Wadler, Philip. "The essence of functional programming." Proceedings of the 19th ACM SIGPLAN-SIGACT symposium on Principles of programming languages. 1992.

<a name="F5">[5]</a> Newbern, Jeff. "All About Monads." Online at https://wiki.haskell.org/All_About_Monads (last accessed 19 August 2022). 2021.

<a name="F6">[6]</a> 생략된 부분을 찾아 읽는 것은 도움이 되지 않는다. 첫 문단의 생략된 부분에는 오직 독자들의 혼란을 늘리는 데만 기여하는 불필요한 지엽적인 부분들에 대한 지적들 말고는 아무 것도 없다. 세 번째 문단의 생략된 부분은 믿기지 않게도 첫 번째 문단의 것보다 더 무가치하다.

<a name="F7">[7]</a> Moggi의 아이디어는 결국 `T<A>`타입을 통해 '`A`타입의' 계산을 나타내는 것이다. 문제는 `A`타입의 값을 여러 개 반환하는 표현식을 '`A`타입의' 계산으로 볼 수 있는가다. '`A`타입의' 계산이라는 말은 그것이 `A`타입을 반환한다는 것을 뜻하지 않는가? 적어도 Moggi의 논문에서는 그랬다. '`A` 타입의' 라는 말을 아주 포괄적으로 해석한다면 `A`타입의 값을 여러 개 반환하는 표현식도 `A`타입의 계산이라고 볼 수 있겠지만 그렇게 매번 편한대로 용어를 해석하는 건 정합적인 설명을 포기하는 것과 마찬가지다.

<a name="F8">[8]</a> Online at https://en.wikipedia.org/wiki/Monad_(functional_programming) (last accessed 19 August 2022). 2022.

<a name="F9">[9]</a> C. A. McCann's answer (Jul 23 '10 at 23:39) on "How and why does the Haskell Cont monad work?" Online at https://stackoverflow.com/questions/3322540/how-and-why-does-the-haskell-cont-monad-work (last accessed 19 August 2022). 2010.

<a name="F10">[10]</a> Kow, Eric. "Of monads and space suits." Online at http://web.archive.org/web/20081206204420/http://www.loria.fr/~kow/monads/index.html (last accessed 17 November 2022). 2005.

<a name="F11">[11]</a> 가령 모나드의 용도를 전혀 모르는 사람이 이 은유를 본다고 생각해 보라. 그는 모나드가 우주복처럼 내용물을 안전하게 보존하는 데 쓰이는 도구라고 생각할 것이다. 불행히도 모나드와 함께 강조되는 "순수성" 등의 키워드는 그 생각을 더욱 그럴듯해 보이게 할 가능성이 높다. 

<a name="F12">[12]</a> 이 요약이 혼란스럽게 느껴진다면 그것은 내 잘못이 아니다. 요약되지 않은 저자의 설명은 훨씬 더 나쁘다. 나는 독자들의 정신건강을 위해 그것을 이 글에서 직접 인용하지는 않았다. 그러나 '피네간의 경야(Finnegans Wake)' 보다 당혹스럽고 포스트구조주의 철학자들의 담론보다 이해하기 힘든 그 횡설수설을 굳이 읽어 보고자 하는 독자가 있다면 해당 튜토리얼의 "State and bind robot" 이라는 소제목이 달린 부분을 확인해 보라.

<a name="F13">[13]</a> 물론 `unit`과 `join`이 꼭 의미가 유사한 타입들 사이의 무엇을 무엇으로 볼 수 있는 관계를 나타낼 거라는 보장은 없다. 그러나 그들이 그런 관계를 나타낼 개연성은 높다. 모나드 규칙에 의하면 `unit`과 `join`은 값들 사이의 함수적 관계 일부를 보존해야 하기 때문이다. 모나드 규칙이 어떤 식으로 위 해석과 연결되는지는 다른 글에서 더 자세히 다루어질 것이다.
